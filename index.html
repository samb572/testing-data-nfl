<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QB Fantasy Projections with Matchup Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            background: #f8fafc;
            border-bottom: 2px solid #e5e7eb;
        }

        .nav-tab {
            flex: 1;
            padding: 15px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: #64748b;
            transition: all 0.3s;
        }

        .nav-tab.active {
            color: #2563eb;
            background: white;
            border-bottom: 2px solid #2563eb;
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
        }

        .sidebar {
            background: #f8fafc;
            border-radius: 15px;
            padding: 25px;
            height: fit-content;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .input-group select,
        .input-group input,
        .input-group input[type="file"] {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .input-group select:focus,
        .input-group input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .project-btn, .audit-btn {
            width: 100%;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            margin-bottom: 10px;
        }

        .audit-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .project-btn:hover, .audit-btn:hover {
            transform: translateY(-2px);
        }

        .project-btn:disabled, .audit-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-area {
            background: white;
            border-radius: 15px;
            padding: 25px;
        }

        .projection-card {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 5px solid #0ea5e9;
            position: relative;
        }

        /* Matchup highlight overlays */
        .boom-matchup {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border-left: 5px solid #10b981;
            box-shadow: 0 0 25px rgba(16, 185, 129, 0.15);
        }

        .bust-matchup {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border-left: 5px solid #ef4444;
            box-shadow: 0 0 25px rgba(239, 68, 68, 0.15);
        }

        .neutral-matchup {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-left: 5px solid #64748b;
        }

        .projection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .qb-name {
            font-size: 1.5rem;
            font-weight: 700;
            color: #0f172a;
        }

        .opponent {
            background: #dc2626;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .matchup-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 8px 16px;
            border-radius: 25px;
            font-weight: 700;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .boom-indicator {
            background: #10b981;
            color: white;
        }

        .bust-indicator {
            background: #ef4444;
            color: white;
        }

        .neutral-indicator {
            background: #64748b;
            color: white;
        }

        .projection-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #0ea5e9;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #64748b;
            font-weight: 500;
        }

        .confidence-interval {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid #3b82f6;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .confidence-title {
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 10px;
        }

        .confidence-range {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1rem;
        }

        .confidence-low, .confidence-high {
            font-weight: 600;
            color: #1e40af;
        }

        .matchup-analysis {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .analysis-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .matchup-factors {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .factor-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #e5e7eb;
        }

        .boom-factor {
            border-left-color: #10b981;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }

        .bust-factor {
            border-left-color: #ef4444;
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
        }

        .neutral-factor {
            border-left-color: #64748b;
        }

        .factor-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .factor-description {
            font-size: 0.9rem;
            color: #64748b;
        }

        .statistical-metrics {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .metrics-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 15px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .metric-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #0f172a;
        }

        .metric-label {
            font-size: 0.8rem;
            color: #64748b;
            margin-top: 5px;
        }

        .breakdown-section {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .breakdown-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 15px;
        }

        .breakdown-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .breakdown-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .breakdown-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #0f172a;
        }

        .breakdown-label {
            font-size: 0.8rem;
            color: #64748b;
            margin-top: 5px;
        }

        .defense-insights {
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .defense-insights h4 {
            color: #374151;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .defense-stat {
            background: rgba(59, 130, 246, 0.1);
            color: #1e40af;
            padding: 8px 12px;
            border-radius: 6px;
            margin: 5px;
            display: inline-block;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .csv-info {
            background: #f0f9ff;
            border: 1px solid #bfdbfe;
            color: #1e40af;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-size: 0.9rem;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e5e7eb;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #059669);
            transition: width 0.3s ease;
        }

        .loading {
            text-align: center;
            color: #64748b;
            font-style: italic;
            padding: 40px;
        }

        .error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .success {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: #059669;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .github-link {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 25px;
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s;
            z-index: 1000;
        }

        .github-link:hover {
            background: rgba(0, 0, 0, 0.9);
            transform: scale(1.05);
        }

        /* Audit styles */
        .audit-summary {
            background: linear-gradient(135deg, #fef3c7 0%, #fef3c7 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            border-left: 5px solid #f59e0b;
        }

        .player-audit-card {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #10b981;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .player-name {
            font-size: 1.3rem;
            font-weight: 700;
            color: #0f172a;
        }

        .accuracy-score {
            background: #10b981;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .weekly-breakdown {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .week-item {
            background: white;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.9rem;
            border-left: 3px solid #e5e7eb;
        }

        .week-boom {
            border-left-color: #10b981;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }

        .week-bust {
            border-left-color: #ef4444;
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
        }

        .week-projected {
            color: #059669;
            font-weight: 600;
        }

        .week-actual {
            color: #dc2626;
            font-weight: 600;
        }

        .week-diff {
            color: #6b7280;
            font-size: 0.8rem;
        }

        @media (max-width: 968px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }

            .github-link {
                position: static;
                display: block;
                margin: 10px auto;
                width: fit-content;
            }

            .matchup-indicator {
                position: static;
                margin-bottom: 15px;
                align-self: flex-start;
            }

            .projection-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <a href="https://github.com/yourusername/qb-projections" target="_blank" class="github-link">
        ⭐ Star on GitHub
    </a>

    <div class="container">
        <div class="header">
            <h1>🏈 QB Matchup Analyzer</h1>
            <p>Statistically Enhanced Projections with Confidence Intervals</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchTab('projection')">Matchup Analysis</button>
            <button class="nav-tab" onclick="switchTab('audit')">Season Audit</button>
        </div>

        <!-- Single Projection Tab -->
        <div id="projection-tab" class="tab-content active">
            <div class="main-content">
                <div class="sidebar">
                    <div class="input-group">
                        <label for="qb-select">Select Quarterback</label>
                        <select id="qb-select">
                            <option value="">Loading QBs...</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="opponent-select">Select Opponent</label>
                        <select id="opponent-select">
                            <option value="">Loading Teams...</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="spread-input">Point Spread (+ if favored)</label>
                        <input type="number" id="spread-input" step="0.5" placeholder="e.g., -3.5">
                    </div>

                    <div class="input-group">
                        <label for="total-input">Game Total (O/U)</label>
                        <input type="number" id="total-input" step="0.5" placeholder="e.g., 47.5">
                    </div>

                    <div class="input-group">
                        <label for="confidence-level">Confidence Level</label>
                        <select id="confidence-level">
                            <option value="68">68% (1σ)</option>
                            <option value="90">90%</option>
                            <option value="95" selected>95% (2σ)</option>
                            <option value="99">99%</option>
                        </select>
                    </div>

                    <button class="project-btn" onclick="generateProjection()">
                        Analyze Matchup
                    </button>

                    <div id="status-message"></div>
                </div>

                <div class="results-area">
                    <div id="projection-results">
                        <div class="loading">
                            Select a quarterback and opponent to analyze the matchup...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Season Audit Tab -->
        <div id="audit-tab" class="tab-content">
            <div class="main-content">
                <div class="sidebar">
                    <div class="input-group">
                        <label for="csv-upload">Upload 2024 NFL Odds CSV</label>
                        <input type="file" id="csv-upload" accept=".csv" onchange="handleCSVUpload(event)">
                        <div class="csv-info">
                            Upload the NFL DraftKings odds CSV to perform a bulk season audit.
                        </div>
                    </div>

                    <div class="input-group">
                        <label for="gamelog-upload">Upload QB Game Log CSV</label>
                        <input type="file" id="gamelog-upload" accept=".csv" onchange="handleGameLogUpload(event)">
                        <div class="csv-info">
                            Upload the FantasyPros QB fantasy points CSV for actual game results.
                        </div>
                    </div>

                    <div class="input-group">
                        <label for="min-games">Minimum Games Played</label>
                        <input type="number" id="min-games" value="10" min="1" max="17">
                    </div>

                    <button class="audit-btn" id="audit-btn" onclick="runSeasonAudit()" disabled>
                        Run Statistical Audit
                    </button>

                    <div id="audit-progress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill" style="width: 0%;"></div>
                        </div>
                        <div id="progress-text">Processing...</div>
                    </div>

                    <div id="audit-status"></div>
                </div>

                <div class="results-area">
                    <div id="audit-results">
                        <div class="loading">
                            Upload CSV files and click "Run Statistical Audit" to analyze QB projections...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Supabase setup
        const SUPABASE_URL = 'https://ooxzkffzedtfiiparnrz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9veHprZmZ6ZWR0ZmlpcGFybnJ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE5Mzk5NzgsImV4cCI6MjA2NzUxNTk3OH0.exRTwGBwMWC-fpZvySHnxBEOpPpytHzKRO_s5FlnMhA';
        
        let supabaseClient;
        let qbData = [];
        let defenseData = [];
        let csvData = [];
        let gameLogData = [];

        // Initialize Supabase when DOM loads
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                const { createClient } = supabase;
                supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('🚀 Application loaded successfully');
                console.log('📊 Loading data from Supabase...');
                await Promise.all([loadQBData(), loadDefenseData()]);
            } catch (error) {
                console.error('❌ Failed to initialize:', error);
                showStatus('Failed to initialize database connection', 'error');
            }
        });

        // Enhanced QB Projector with Statistical Rigor
        class EnhancedQBMatchupAnalyzer {
            constructor() {
                // More conservative game script adjustments based on empirical data
                this.gameScriptAdjustments = {
                    spread: {
                        bigFavorite: 0.88,    // -14+ (reduced variance, more conservative)
                        favorite: 0.94,       // -7 to -13.5 
                        smallFavorite: 0.97,  // -3 to -6.5
                        pickEm: 1.0,          // -2.5 to +2.5
                        smallUnderdog: 1.03,  // +3 to +6.5
                        underdog: 1.08,       // +7 to +13.5 (more conservative boost)
                        bigUnderdog: 1.15     // +14+ (reduced from previous for stability)
                    },
                    total: {
                        veryLow: 0.85,    // Under 40
                        low: 0.93,        // 40-44.5
                        average: 1.0,     // 45-49.5
                        high: 1.06,       // 50-54.5 (more conservative)
                        veryHigh: 1.12    // 55+ (reduced for stability)
                    }
                };

                // Enhanced statistical parameters
                this.statisticalParams = {
                    // Variance multipliers based on matchup type and QB tier
                    varianceMultipliers: {
                        elite: { boom: 1.15, neutral: 1.0, bust: 0.92 },
                        good: { boom: 1.22, neutral: 1.08, bust: 0.95 },
                        average: { boom: 1.35, neutral: 1.15, bust: 1.05 },
                        poor: { boom: 1.45, neutral: 1.25, bust: 1.15 }
                    },
                    // Base standard deviation as percentage of projection
                    baseStdDevPct: 0.18, // 18% of projection value
                    // Minimum sample size considerations
                    minDropbacksForConfidence: 200,
                    // Regression to mean factor
                    regressionFactor: 0.15
                };

                // Refined boom/bust criteria with statistical backing
                this.matchupCriteria = {
                    boom: {
                        conditions: [
                            { type: 'defense', rank: 28, points: 2.5, weight: 0.25 },
                            { type: 'defense', rank: 25, points: 1.5, weight: 0.15 },
                            { type: 'total', value: 52, points: 2.0, weight: 0.20 },
                            { type: 'total', value: 49, points: 1.0, weight: 0.10 },
                            { type: 'spread', value: 10, points: 2.0, weight: 0.20 },
                            { type: 'spread', value: 7, points: 1.0, weight: 0.15 },
                            { type: 'passD', rating: 105, points: 1.5, weight: 0.18 },
                            { type: 'pressure', pct: 4.5, points: 1.2, weight: 0.12 },
                            { type: 'ypa', value: 7.5, points: 1.0, weight: 0.10 }
                        ],
                        threshold: 3.0
                    },
                    bust: {
                        conditions: [
                            { type: 'defense', rank: 5, points: 2.5, weight: 0.25 },
                            { type: 'defense', rank: 10, points: 1.5, weight: 0.15 },
                            { type: 'total', value: 42, points: 1.8, weight: 0.18 },
                            { type: 'spread', value: -14, points: 2.2, weight: 0.22 },
                            { type: 'spread', value: -10, points: 1.2, weight: 0.12 },
                            { type: 'passD', rating: 85, points: 1.5, weight: 0.18 },
                            { type: 'pressure', pct: 8, points: 1.5, weight: 0.15 },
                            { type: 'ypa', value: 6.2, points: 1.0, weight: 0.10 }
                        ],
                        threshold: 3.0
                    }
                };
            }

            // Enhanced QB tier determination with sample size considerations
            determineQBTier(qb) {
                const fpPerDB = qb.weighted_fp_per_db || 0.4;
                const totalDropbacks = qb.total_dropbacks || 500;
                
                // Adjust thresholds based on sample size confidence
                const confidenceAdjustment = Math.min(1.0, totalDropbacks / this.statisticalParams.minDropbacksForConfidence);
                const adjustedFpPerDB = fpPerDB * (0.7 + 0.3 * confidenceAdjustment); // Regression to mean for small samples
                
                if (adjustedFpPerDB >= 0.50 && totalDropbacks >= 400) return 'elite';
                else if (adjustedFpPerDB >= 0.45 && totalDropbacks >= 300) return 'good';
                else if (adjustedFpPerDB >= 0.42 && totalDropbacks >= 200) return 'average';
                else return 'poor';
            }

            // Calculate confidence intervals using statistical modeling
            calculateConfidenceInterval(projection, qbTier, matchupType, confidenceLevel = 95) {
                const baseStdDev = projection * this.statisticalParams.baseStdDevPct;
                const varianceMultiplier = this.statisticalParams.varianceMultipliers[qbTier][matchupType];
                const adjustedStdDev = baseStdDev * varianceMultiplier;
                
                // Z-scores for different confidence levels
                const zScores = { 68: 1.0, 90: 1.645, 95: 1.96, 99: 2.576 };
                const zScore = zScores[confidenceLevel] || 1.96;
                
                const margin = adjustedStdDev * zScore;
                
                return {
                    lower: Math.max(0, projection - margin),
                    upper: projection + margin,
                    stdDev: adjustedStdDev,
                    margin: margin
                };
            }

            // Enhanced statistical metrics calculation
            calculateStatisticalMetrics(qb, projection, confidenceInterval) {
                const sampleSize = qb.total_dropbacks || 500;
                const fpPerDB = qb.weighted_fp_per_db || 0.4;
                
                // Standard error calculation
                const standardError = confidenceInterval.stdDev / Math.sqrt(Math.max(1, sampleSize / 35)); // ~35 dropbacks per game
                
                // Coefficient of variation (relative volatility)
                const coefficientOfVariation = confidenceInterval.stdDev / projection;
                
                // Sample size adequacy score
                const sampleAdequacy = Math.min(1.0, sampleSize / this.statisticalParams.minDropbacksForConfidence);
                
                // Projection reliability score (0-100)
                const reliabilityScore = Math.round(sampleAdequacy * (1 - Math.min(0.5, coefficientOfVariation)) * 100);
                
                return {
                    standardError: standardError,
                    coefficientOfVariation: coefficientOfVariation,
                    sampleAdequacy: sampleAdequacy,
                    reliabilityScore: reliabilityScore,
                    sampleSize: sampleSize
                };
            }

            // Weighted matchup analysis with statistical backing
            analyzeMatchup(gameContext, opponentDefense, qbTier) {
                let boomScore = 0;
                let bustScore = 0;
                let boomWeight = 0;
                let bustWeight = 0;
                const boomFactors = [];
                const bustFactors = [];
                
                // Calculate weighted boom score
                this.matchupCriteria.boom.conditions.forEach(condition => {
                    if (this.evaluateCondition(condition, gameContext, opponentDefense)) {
                        boomScore += condition.points * condition.weight;
                        boomWeight += condition.weight;
                        boomFactors.push(this.getConditionDescription(condition, gameContext, opponentDefense));
                    }
                });

                // Calculate weighted bust score
                this.matchupCriteria.bust.conditions.forEach(condition => {
                    if (this.evaluateCondition(condition, gameContext, opponentDefense)) {
                        bustScore += condition.points * condition.weight;
                        bustWeight += condition.weight;
                        bustFactors.push(this.getConditionDescription(condition, gameContext, opponentDefense));
                    }
                });

                // Normalize scores by weight
                const normalizedBoomScore = boomWeight > 0 ? boomScore / boomWeight : 0;
                const normalizedBustScore = bustWeight > 0 ? bustScore / bustWeight : 0;

                // Determine matchup type with higher threshold for reliability
                let matchupType = 'neutral';
                if (normalizedBoomScore >= this.matchupCriteria.boom.threshold && normalizedBoomScore > normalizedBustScore * 1.2) {
                    matchupType = 'boom';
                } else if (normalizedBustScore >= this.matchupCriteria.bust.threshold && normalizedBustScore > normalizedBoomScore * 1.2) {
                    matchupType = 'bust';
                }

                return {
                    matchupType,
                    boomScore: normalizedBoomScore,
                    bustScore: normalizedBustScore,
                    boomFactors,
                    bustFactors,
                    boomWeight,
                    bustWeight
                };
            }

            evaluateCondition(condition, gameContext, opponentDefense) {
                switch (condition.type) {
                    case 'defense':
                        return opponentDefense && (opponentDefense.rank || 16) >= condition.rank;
                    case 'total':
                        return gameContext.total && gameContext.total >= condition.value;
                    case 'spread':
                        if (condition.value > 0) {
                            return gameContext.spread && gameContext.spread >= condition.value;
                        } else {
                            return gameContext.spread && gameContext.spread <= condition.value;
                        }
                    case 'passD':
                        return opponentDefense && (opponentDefense.overall_rating || 95) >= condition.rating;
                    case 'pressure':
                        const sackPct = opponentDefense ? (opponentDefense.overall_sack_pct || opponentDefense.man_sack_pct || 6) : 6;
                        return condition.pct > 6 ? sackPct >= condition.pct : sackPct <= condition.pct;
                    case 'ypa':
                        const ypa = opponentDefense ? (opponentDefense.overall_ypa || opponentDefense.man_yards_per_attempt || 7) : 7;
                        return condition.value > 7 ? ypa >= condition.value : ypa <= condition.value;
                    default:
                        return false;
                }
            }

            getConditionDescription(condition, gameContext, opponentDefense) {
                switch (condition.type) {
                    case 'defense':
                        const rank = opponentDefense ? opponentDefense.rank : 'Unknown';
                        return `Weak Defense (Rank ${rank})`;
                    case 'total':
                        return `High Total (${gameContext.total})`;
                    case 'spread':
                        if (condition.value > 0) {
                            return `Big Underdog (+${gameContext.spread})`;
                        } else {
                            return `Heavy Favorite (${gameContext.spread})`;
                        }
                    case 'passD':
                        const rating = opponentDefense ? (opponentDefense.overall_rating || 95).toFixed(1) : 'N/A';
                        return `Poor Pass Defense (${rating} rating)`;
                    case 'pressure':
                        const sackPct = opponentDefense ? (opponentDefense.overall_sack_pct || opponentDefense.man_sack_pct || 6).toFixed(1) : 'N/A';
                        return condition.pct > 6 ? `Heavy Pressure (${sackPct}%)` : `Low Pressure (${sackPct}%)`;
                    case 'ypa':
                        const ypa = opponentDefense ? (opponentDefense.overall_ypa || opponentDefense.man_yards_per_attempt || 7).toFixed(1) : 'N/A';
                        return condition.value > 7 ? `Big Play Prone (${ypa} YPA)` : `Limits Big Plays (${ypa} YPA)`;
                    default:
                        return 'Unknown Factor';
                }
            }
            
            calculateProjection(qb, gameContext, opponentDefense = null, confidenceLevel = 95) {
                try {
                    // Use database stats as foundation with regression adjustment
                    const qbTier = this.determineQBTier(qb);
                    let baseFPPerDB = qb.weighted_fp_per_db || 0.4;
                    const seasonDropbacks = qb.total_dropbacks || 500;
                    
                    // Apply regression to mean for sample size
                    const sampleAdequacy = Math.min(1.0, seasonDropbacks / this.statisticalParams.minDropbacksForConfidence);
                    const leagueAvgFPPerDB = 0.43; // League average
                    baseFPPerDB = baseFPPerDB * sampleAdequacy + leagueAvgFPPerDB * (1 - sampleAdequacy) * this.statisticalParams.regressionFactor;
                    
                    let estimatedDropbacks = Math.round(seasonDropbacks / 17);
                    
                    // Apply more conservative game script adjustments
                    let gameScriptMultiplier = 1.0;
                    let dropbackAdjustment = 1.0;
                    
                    // Spread adjustments with confidence weighting
                    if (gameContext.spread !== null) {
                        const spread = gameContext.spread;
                        if (spread <= -14) {
                            gameScriptMultiplier *= this.gameScriptAdjustments.spread.bigFavorite;
                            dropbackAdjustment *= 0.90;
                        }
                        else if (spread <= -7) {
                            gameScriptMultiplier *= this.gameScriptAdjustments.spread.favorite;
                            dropbackAdjustment *= 0.96;
                        }
                        else if (spread <= -3) gameScriptMultiplier *= this.gameScriptAdjustments.spread.smallFavorite;
                        else if (spread <= 2.5) gameScriptMultiplier *= this.gameScriptAdjustments.spread.pickEm;
                        else if (spread <= 6.5) {
                            gameScriptMultiplier *= this.gameScriptAdjustments.spread.smallUnderdog;
                            dropbackAdjustment *= 1.02;
                        }
                        else if (spread <= 13.5) {
                            gameScriptMultiplier *= this.gameScriptAdjustments.spread.underdog;
                            dropbackAdjustment *= 1.06;
                        }
                        else {
                            gameScriptMultiplier *= this.gameScriptAdjustments.spread.bigUnderdog;
                            dropbackAdjustment *= 1.12;
                        }
                    }
                    
                    // Total adjustments
                    if (gameContext.total !== null) {
                        const total = gameContext.total;
                        if (total < 40) gameScriptMultiplier *= this.gameScriptAdjustments.total.veryLow;
                        else if (total < 45) gameScriptMultiplier *= this.gameScriptAdjustments.total.low;
                        else if (total < 50) gameScriptMultiplier *= this.gameScriptAdjustments.total.average;
                        else if (total < 55) gameScriptMultiplier *= this.gameScriptAdjustments.total.high;
                        else gameScriptMultiplier *= this.gameScriptAdjustments.total.veryHigh;
                    }

                    // Enhanced defense impact analysis
                    let defenseMultiplier = 1.0;
                    let defenseInsights = null;
                    if (opponentDefense) {
                        const defenseAnalysis = this.analyzeDefenseByStats(opponentDefense);
                        defenseMultiplier = defenseAnalysis.multiplier;
                        defenseInsights = defenseAnalysis.insights;
                    }
                    
                    // Calculate base projection
                    estimatedDropbacks = Math.round(estimatedDropbacks * dropbackAdjustment);
                    const totalMultiplier = gameScriptMultiplier * defenseMultiplier;
                    const adjustedFPPerDB = baseFPPerDB * totalMultiplier;
                    const totalProjectedFP = adjustedFPPerDB * estimatedDropbacks;
                    
                    // Analyze matchup
                    const matchupAnalysis = this.analyzeMatchup(gameContext, opponentDefense, qbTier);
                    
                    // Calculate confidence interval
                    const confidenceInterval = this.calculateConfidenceInterval(
                        totalProjectedFP, 
                        qbTier, 
                        matchupAnalysis.matchupType, 
                        confidenceLevel
                    );
                    
                    // Calculate statistical metrics
                    const statisticalMetrics = this.calculateStatisticalMetrics(qb, totalProjectedFP, confidenceInterval);
                    
                    return {
                        baseFPPerDB: baseFPPerDB,
                        adjustedFPPerDB: adjustedFPPerDB,
                        estimatedDropbacks: estimatedDropbacks,
                        totalProjectedFP: totalProjectedFP,
                        qbTier: qbTier,
                        matchupAnalysis: matchupAnalysis,
                        gameScriptMultiplier: gameScriptMultiplier,
                        defenseMultiplier: defenseMultiplier,
                        totalMultiplier: totalMultiplier,
                        dropbackAdjustment: dropbackAdjustment,
                        defenseInsights: defenseInsights,
                        confidenceInterval: confidenceInterval,
                        statisticalMetrics: statisticalMetrics,
                        adjustmentBreakdown: {
                            spreadAdj: gameContext.spread !== null ? this.getSpreadMultiplier(gameContext.spread) : 1.0,
                            totalAdj: gameContext.total !== null ? this.getTotalMultiplier(gameContext.total) : 1.0,
                            defenseAdj: defenseMultiplier,
                            dropbackAdj: dropbackAdjustment
                        }
                    };
                } catch (error) {
                    console.error('❌ Projection calculation error:', error);
                    return null;
                }
            }

            analyzeDefenseByStats(defense) {
                let multiplier = 1.0;
                const insights = {
                    stats: [],
                    strengths: [],
                    weaknesses: []
                };

                const overallRating = defense.overall_rating || 95;
                const rank = defense.rank || 16;
                
                // More conservative defense adjustments with statistical backing
                if (rank <= 5) {
                    multiplier *= 0.85; // Reduced from 0.82
                    insights.strengths.push(`Elite Defense (Rank ${rank})`);
                } else if (rank <= 12) {
                    multiplier *= 0.92; // Reduced from 0.90
                    insights.strengths.push(`Strong Defense (Rank ${rank})`);
                } else if (rank >= 28) {
                    multiplier *= 1.15; // Reduced from 1.18
                    insights.weaknesses.push(`Terrible Defense (Rank ${rank})`);
                } else if (rank >= 22) {
                    multiplier *= 1.06; // Reduced from 1.08
                    insights.weaknesses.push(`Poor Defense (Rank ${rank})`);
                }

                // Pass defense rating impact (more conservative)
                if (overallRating >= 110) {
                    multiplier *= 1.10; // Reduced from 1.12
                    insights.stats.push(`Awful Pass D (${overallRating.toFixed(1)} rating)`);
                } else if (overallRating >= 102) {
                    multiplier *= 1.04; // Reduced from 1.06
                    insights.stats.push(`Poor Pass D (${overallRating.toFixed(1)} rating)`);
                } else if (overallRating <= 80) {
                    multiplier *= 0.90; // Less severe than 0.88
                    insights.stats.push(`Elite Pass D (${overallRating.toFixed(1)} rating)`);
                } else if (overallRating <= 88) {
                    multiplier *= 0.96; // Less severe than 0.94
                    insights.stats.push(`Strong Pass D (${overallRating.toFixed(1)} rating)`);
                }

                // Pressure impact (more conservative)
                const sackPct = defense.overall_sack_pct || defense.man_sack_pct || 6;
                if (sackPct >= 9) {
                    multiplier *= 0.88; // Less severe than 0.85
                    insights.stats.push(`Heavy Pressure (${sackPct.toFixed(1)}% sacks)`);
                } else if (sackPct <= 4) {
                    multiplier *= 1.08; // Reduced from 1.10
                    insights.stats.push(`No Pressure (${sackPct.toFixed(1)}% sacks)`);
                }

                // Big play tendency (more conservative)
                const ypaAllowed = defense.overall_ypa || defense.man_yards_per_attempt || 7.0;
                if (ypaAllowed >= 8.0) {
                    multiplier *= 1.06; // Reduced from 1.08
                    insights.stats.push(`Big Play Prone (${ypaAllowed.toFixed(1)} YPA)`);
                } else if (ypaAllowed <= 6.0) {
                    multiplier *= 0.94; // Less severe than 0.92
                    insights.stats.push(`Limits Big Plays (${ypaAllowed.toFixed(1)} YPA)`);
                }

                return { multiplier, insights };
            }
            
            getSpreadMultiplier(spread) {
                if (spread <= -14) return this.gameScriptAdjustments.spread.bigFavorite;
                else if (spread <= -7) return this.gameScriptAdjustments.spread.favorite;
                else if (spread <= -3) return this.gameScriptAdjustments.spread.smallFavorite;
                else if (spread <= 2.5) return this.gameScriptAdjustments.spread.pickEm;
                else if (spread <= 6.5) return this.gameScriptAdjustments.spread.smallUnderdog;
                else if (spread <= 13.5) return this.gameScriptAdjustments.spread.underdog;
                else return this.gameScriptAdjustments.spread.bigUnderdog;
            }
            
            getTotalMultiplier(total) {
                if (total < 40) return this.gameScriptAdjustments.total.veryLow;
                else if (total < 45) return this.gameScriptAdjustments.total.low;
                else if (total < 50) return this.gameScriptAdjustments.total.average;
                else if (total < 55) return this.gameScriptAdjustments.total.high;
                else return this.gameScriptAdjustments.total.veryHigh;
            }
        }

        const projector = new EnhancedQBMatchupAnalyzer();

        // Load QB data from Supabase
        async function loadQBData() {
            try {
                console.log('📈 Loading QB data...');
                
                const { data, error } = await supabaseClient
                    .from('players')
                    .select('name, team, weighted_fp_per_db, total_dropbacks')
                    .not('name', 'is', null)
                    .not('team', 'is', null)
                    .gt('weighted_fp_per_db', 0.1)
                    .order('weighted_fp_per_db', { ascending: false })
                    .limit(50);

                if (error) {
                    console.error('❌ Supabase error:', error);
                    throw new Error(`Database error: ${error.message}`);
                }

                if (!data || data.length === 0) {
                    throw new Error('No quarterback data found');
                }

                qbData = data;
                console.log(`✅ Loaded ${qbData.length} quarterbacks`);
                
                populateQBSelect();
                showStatus('Quarterback data loaded successfully!', 'success');

            } catch (error) {
                console.error('❌ Error loading QB data:', error);
                showStatus(`Failed to load QB data: ${error.message}`, 'error');
                
                const select = document.getElementById('qb-select');
                select.innerHTML = '<option value="">Failed to load QBs - check console</option>';
            }
        }

        // Load Defense data from Supabase
        async function loadDefenseData() {
            try {
                console.log('🛡️ Loading defense data...');
                
                const { data, error } = await supabaseClient
                    .from('opponent_defense_tendencies')
                    .select('*')
                    .order('team', { ascending: true });

                if (error) {
                    console.error('❌ Defense data error:', error);
                    throw new Error(`Defense data error: ${error.message}`);
                }

                if (!data || data.length === 0) {
                    console.warn('⚠️ No defense data found');
                    return;
                }

                defenseData = data;
                console.log(`✅ Loaded ${defenseData.length} team defenses`);
                
                populateOpponentSelect();
                checkAuditButtonStatus();

            } catch (error) {
                console.error('❌ Error loading defense data:', error);
                defenseData = [];
                populateOpponentSelect();
            }
        }

        function populateQBSelect() {
            const select = document.getElementById('qb-select');
            select.innerHTML = '<option value="">Select a quarterback</option>';

            qbData.forEach((qb) => {
                const tier = projector.determineQBTier(qb);
                const option = document.createElement('option');
                option.value = qb.name;
                option.textContent = `${qb.name} (${qb.team}) - ${qb.weighted_fp_per_db.toFixed(3)} FP/DB`;
                select.appendChild(option);
            });
        }

        function populateOpponentSelect() {
            const select = document.getElementById('opponent-select');
            select.innerHTML = '<option value="">Select opponent</option>';

            if (defenseData.length > 0) {
                defenseData.forEach((team) => {
                    const option = document.createElement('option');
                    option.value = team.team;
                    option.textContent = `${team.team_name || team.team} (${team.team})`;
                    select.appendChild(option);
                });
            } else {
                const teams = [
                    'ARI', 'ATL', 'BAL', 'BUF', 'CAR', 'CHI', 'CIN', 'CLE', 'DAL', 'DEN',
                    'DET', 'GB', 'HOU', 'IND', 'JAX', 'KC', 'LV', 'LAC', 'LAR', 'MIA',
                    'MIN', 'NE', 'NO', 'NYG', 'NYJ', 'PHI', 'PIT', 'SF', 'SEA', 'TB', 'TEN', 'WAS'
                ];
                teams.forEach(team => {
                    const option = document.createElement('option');
                    option.value = team;
                    option.textContent = team;
                    select.appendChild(option);
                });
            }
        }

        function switchTab(tabName) {
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        function generateProjection() {
            const qbName = document.getElementById('qb-select').value;
            const opponentTeam = document.getElementById('opponent-select').value;
            const spread = parseFloat(document.getElementById('spread-input').value) || null;
            const total = parseFloat(document.getElementById('total-input').value) || null;
            const confidenceLevel = parseInt(document.getElementById('confidence-level').value) || 95;

            if (!qbName) {
                showStatus('Please select a quarterback', 'error');
                return;
            }

            if (!opponentTeam) {
                showStatus('Please select an opponent', 'error');
                return;
            }

            const selectedQB = qbData.find(qb => qb.name === qbName);
            if (!selectedQB) {
                showStatus('Quarterback not found', 'error');
                return;
            }

            const opponentDefense = defenseData.find(def => def.team === opponentTeam);
            const gameContext = { spread, total };
            const projection = projector.calculateProjection(selectedQB, gameContext, opponentDefense, confidenceLevel);
            
            if (projection) {
                displayProjection(selectedQB, projection, gameContext, opponentDefense, confidenceLevel);
                showStatus(`Enhanced matchup analyzed: ${projection.matchupAnalysis.matchupType} spot! (${projection.statisticalMetrics.reliabilityScore}% reliability)`, 'success');
            } else {
                showStatus('Failed to generate projection', 'error');
            }
        }

        function displayProjection(qb, projection, gameContext, opponentDefense, confidenceLevel) {
            const resultsDiv = document.getElementById('projection-results');
            
            const opponentName = opponentDefense ? (opponentDefense.team_name || opponentDefense.team) : opponentTeam;
            const opponentTeam = opponentDefense ? opponentDefense.team : gameContext.opponent || 'UNK';
            
            // Determine card styling based on matchup type
            let cardClass = 'projection-card';
            let indicatorClass = 'matchup-indicator';
            let indicatorText = '';
            let indicatorIcon = '';

            switch (projection.matchupAnalysis.matchupType) {
                case 'boom':
                    cardClass += ' boom-matchup';
                    indicatorClass += ' boom-indicator';
                    indicatorText = 'BOOM MATCHUP';
                    indicatorIcon = '🚀';
                    break;
                case 'bust':
                    cardClass += ' bust-matchup';
                    indicatorClass += ' bust-indicator';
                    indicatorText = 'BUST RISK';
                    indicatorIcon = '⚠️';
                    break;
                default:
                    cardClass += ' neutral-matchup';
                    indicatorClass += ' neutral-indicator';
                    indicatorText = 'NEUTRAL';
                    indicatorIcon = '⚖️';
            }

            // Confidence interval display
            const confidenceHTML = `
                <div class="confidence-interval">
                    <div class="confidence-title">📊 ${confidenceLevel}% Confidence Interval</div>
                    <div class="confidence-range">
                        <span class="confidence-low">${projection.confidenceInterval.lower.toFixed(1)}</span>
                        <span style="color: #64748b;">to</span>
                        <span class="confidence-high">${projection.confidenceInterval.upper.toFixed(1)}</span>
                    </div>
                </div>
            `;

            // Statistical metrics display
            const metricsHTML = `
                <div class="statistical-metrics">
                    <div class="metrics-title">📈 Statistical Metrics</div>
                    <div class="metrics-grid">
                        <div class="metric-item">
                            <div class="metric-value">${projection.statisticalMetrics.reliabilityScore}</div>
                            <div class="metric-label">Reliability Score</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${(projection.statisticalMetrics.coefficientOfVariation * 100).toFixed(1)}%</div>
                            <div class="metric-label">Volatility (CV)</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${projection.statisticalMetrics.sampleSize}</div>
                            <div class="metric-label">Sample Size</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${(projection.statisticalMetrics.sampleAdequacy * 100).toFixed(0)}%</div>
                            <div class="metric-label">Sample Adequacy</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">±${projection.confidenceInterval.margin.toFixed(1)}</div>
                            <div class="metric-label">Margin of Error</div>
                        </div>
                        <div class="metric-item">
                            <div class="metric-value">${projection.confidenceInterval.stdDev.toFixed(1)}</div>
                            <div class="metric-label">Standard Deviation</div>
                        </div>
                    </div>
                </div>
            `;

            // Matchup analysis section with weighted scores
            const analysisHTML = `
                <div class="matchup-analysis">
                    <div class="analysis-title">
                        ${indicatorIcon} Weighted Matchup Analysis - ${projection.matchupAnalysis.matchupType.toUpperCase()} SPOT
                    </div>
                    <div class="matchup-factors">
                        ${projection.matchupAnalysis.boomFactors.length > 0 ? `
                            <div class="factor-card boom-factor">
                                <div class="factor-title">🚀 Boom Factors (Score: ${projection.matchupAnalysis.boomScore.toFixed(2)})</div>
                                <div class="factor-description">${projection.matchupAnalysis.boomFactors.join(', ')}</div>
                            </div>
                        ` : ''}
                        
                        ${projection.matchupAnalysis.bustFactors.length > 0 ? `
                            <div class="factor-card bust-factor">
                                <div class="factor-title">⚠️ Bust Factors (Score: ${projection.matchupAnalysis.bustScore.toFixed(2)})</div>
                                <div class="factor-description">${projection.matchupAnalysis.bustFactors.join(', ')}</div>
                            </div>
                        ` : ''}
                        
                        ${projection.matchupAnalysis.boomFactors.length === 0 && projection.matchupAnalysis.bustFactors.length === 0 ? `
                            <div class="factor-card neutral-factor">
                                <div class="factor-title">⚖️ Neutral Matchup</div>
                                <div class="factor-description">No significant boom or bust factors identified</div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;

            let defenseInsightsHTML = '';
            if (projection.defenseInsights) {
                const insights = projection.defenseInsights;
                defenseInsightsHTML = `
                    <div class="defense-insights">
                        <h4>🛡️ Statistical Defense Analysis: ${opponentName}</h4>
                        
                        ${insights.stats.length > 0 ? `
                            <div style="margin-bottom: 10px;">
                                <strong>📊 Key Stats:</strong><br>
                                ${insights.stats.map(s => `<span class="defense-stat">${s}</span>`).join('')}
                            </div>
                        ` : ''}
                        
                        ${insights.strengths.length > 0 ? `
                            <div style="margin-bottom: 10px;">
                                <strong>💪 Strengths:</strong><br>
                                ${insights.strengths.map(s => `<span class="defense-stat">${s}</span>`).join('')}
                            </div>
                        ` : ''}
                        
                        ${insights.weaknesses.length > 0 ? `
                            <div>
                                <strong>🎯 Weaknesses:</strong><br>
                                ${insights.weaknesses.map(w => `<span class="defense-stat">${w}</span>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            resultsDiv.innerHTML = `
                <div class="${cardClass}">
                    <div class="${indicatorClass}">
                        ${indicatorIcon} ${indicatorText}
                    </div>
                    
                    <div class="projection-header">
                        <span class="qb-name">${qb.name} (${qb.team})</span>
                        <span class="opponent">vs ${opponentTeam}</span>
                    </div>
                    
                    ${confidenceHTML}
                    
                    ${analysisHTML}
                    
                    <div class="projection-stats">
                        <div class="stat-card">
                            <div class="stat-value">${projection.totalProjectedFP.toFixed(1)}</div>
                            <div class="stat-label">Projected Fantasy Points</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${projection.baseFPPerDB.toFixed(3)}</div>
                            <div class="stat-label">Adjusted Base FP/DB</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${projection.adjustedFPPerDB.toFixed(3)}</div>
                            <div class="stat-label">Final FP per Dropback</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${projection.estimatedDropbacks}</div>
                            <div class="stat-label">Projected Dropbacks</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${((projection.totalMultiplier - 1) * 100).toFixed(1)}%</div>
                            <div class="stat-label">Total Adjustment</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${projection.qbTier.toUpperCase()}</div>
                            <div class="stat-label">QB Tier</div>
                        </div>
                    </div>
                    
                    ${metricsHTML}
                    
                    <div class="breakdown-section">
                        <div class="breakdown-title">📊 Enhanced Projection Breakdown</div>
                        <div class="breakdown-grid">
                            <div class="breakdown-item">
                                <div class="breakdown-value">${gameContext.spread !== null ? gameContext.spread : 'N/A'}</div>
                                <div class="breakdown-label">Spread</div>
                            </div>
                            <div class="breakdown-item">
                                <div class="breakdown-value">${gameContext.total !== null ? gameContext.total : 'N/A'}</div>
                                <div class="breakdown-label">Game Total</div>
                            </div>
                            <div class="breakdown-item">
                                <div class="breakdown-value">${((projection.adjustmentBreakdown.spreadAdj - 1) * 100).toFixed(1)}%</div>
                                <div class="breakdown-label">Spread Impact</div>
                            </div>
                            <div class="breakdown-item">
                                <div class="breakdown-value">${((projection.adjustmentBreakdown.totalAdj - 1) * 100).toFixed(1)}%</div>
                                <div class="breakdown-label">Total Impact</div>
                            </div>
                            <div class="breakdown-item">
                                <div class="breakdown-value">${((projection.adjustmentBreakdown.defenseAdj - 1) * 100).toFixed(1)}%</div>
                                <div class="breakdown-label">Defense Impact</div>
                            </div>
                            <div class="breakdown-item">
                                <div class="breakdown-value">${((projection.adjustmentBreakdown.dropbackAdj - 1) * 100).toFixed(1)}%</div>
                                <div class="breakdown-label">Volume Impact</div>
                            </div>
                        </div>
                    </div>
                    
                    ${defenseInsightsHTML}
                </div>
            `;
        }

        // Enhanced CSV and audit functions with statistical improvements
        function handleCSVUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showAuditStatus('📁 Parsing odds CSV file...', 'loading');

            const reader = new FileReader();
            reader.onload = function(e) {
                const csv = e.target.result;
                Papa.parse(csv, {
                    header: true,
                    complete: function(results) {
                        csvData = results.data.filter(row => row.game_id && row.home_team && row.away_team);
                        console.log('✅ Odds CSV loaded:', csvData.length, 'games');
                        
                        checkAuditButtonStatus();
                        showAuditStatus(`✅ Odds CSV loaded successfully! ${csvData.length} games found.`, 'success');
                    },
                    error: function(error) {
                        console.error('❌ CSV parsing error:', error);
                        showAuditStatus('❌ Error parsing odds CSV file', 'error');
                    }
                });
            };
            reader.readAsText(file);
        }

        function handleGameLogUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showAuditStatus('📁 Parsing game log CSV file...', 'loading');

            const reader = new FileReader();
            reader.onload = function(e) {
                const csv = e.target.result;
                Papa.parse(csv, {
                    header: true,
                    complete: function(results) {
                        gameLogData = processGameLogData(results.data);
                        console.log('✅ Game log CSV loaded:', Object.keys(gameLogData).length, 'players');
                        
                        checkAuditButtonStatus();
                        showAuditStatus(`✅ Game log CSV loaded successfully! ${Object.keys(gameLogData).length} players found.`, 'success');
                    },
                    error: function(error) {
                        console.error('❌ Game log parsing error:', error);
                        showAuditStatus('❌ Error parsing game log CSV file', 'error');
                    }
                });
            };
            reader.readAsText(file);
        }

        function processGameLogData(rawData) {
            const processed = {};
            
            rawData.forEach(row => {
                if (!row.Player || !row.Team) return;
                
                const playerName = row.Player.trim();
                const team = row.Team.trim();
                
                if (processed[playerName]) return;
                
                const weeklyScores = [];
                
                for (let week = 1; week <= 18; week++) {
                    const score = parseFloat(row[week.toString()]);
                    if (!isNaN(score)) {
                        weeklyScores.push({
                            week: week,
                            points: score
                        });
                    }
                }
                
                if (weeklyScores.length > 0) {
                    processed[playerName] = {
                        team: team,
                        weeklyScores: weeklyScores
                    };
                }
            });
            
            return processed;
        }

        function checkAuditButtonStatus() {
            const auditBtn = document.getElementById('audit-btn');
            if (qbData.length > 0 && csvData.length > 0 && Object.keys(gameLogData).length > 0) {
                auditBtn.disabled = false;
            }
        }

        const teamMapping = {
            'Kansas City Chiefs': 'KC', 'Baltimore Ravens': 'BAL', 'Philadelphia Eagles': 'PHI',
            'Green Bay Packers': 'GB', 'Buffalo Bills': 'BUF', 'Arizona Cardinals': 'ARI',
            'Atlanta Falcons': 'ATL', 'Pittsburgh Steelers': 'PIT', 'New Orleans Saints': 'NO',
            'Carolina Panthers': 'CAR', 'Chicago Bears': 'CHI', 'Tennessee Titans': 'TEN',
            'Cincinnati Bengals': 'CIN', 'New England Patriots': 'NE', 'Indianapolis Colts': 'IND',
            'Houston Texans': 'HOU', 'Miami Dolphins': 'MIA', 'Jacksonville Jaguars': 'JAX',
            'New York Giants': 'NYG', 'Minnesota Vikings': 'MIN', 'Seattle Seahawks': 'SEA',
            'Denver Broncos': 'DEN', 'Los Angeles Chargers': 'LAC', 'Las Vegas Raiders': 'LV',
            'Cleveland Browns': 'CLE', 'Dallas Cowboys': 'DAL', 'Tampa Bay Buccaneers': 'TB',
            'Washington Commanders': 'WAS', 'Los Angeles Rams': 'LAR', 'San Francisco 49ers': 'SF',
            'Detroit Lions': 'DET', 'New York Jets': 'NYJ'
        };

        function normalizeTeamName(teamName) {
            return teamMapping[teamName] || teamName;
        }

        function getWeekFromDate(dateString) {
            const gameDate = new Date(dateString);
            const seasonStart = new Date('2024-09-05');
            const daysDiff = Math.floor((gameDate - seasonStart) / (1000 * 60 * 60 * 24));
            
            if (daysDiff < 126) {
                const week = Math.floor(daysDiff / 7) + 1;
                return Math.max(1, Math.min(18, week));
            } else {
                const playoffWeek = Math.floor((daysDiff - 126) / 7) + 1;
                if (playoffWeek <= 1) return 'WC';
                if (playoffWeek <= 2) return 'DIV';
                if (playoffWeek <= 3) return 'CONF';
                return 'SB';
            }
        }

        function getActualFantasyPoints(playerName, week) {
            const playerData = gameLogData[playerName];
            if (!playerData) {
                const matchingPlayer = Object.keys(gameLogData).find(name => 
                    name.toLowerCase().includes(playerName.toLowerCase().split(' ')[0]) ||
                    playerName.toLowerCase().includes(name.toLowerCase().split(' ')[0])
                );
                
                if (matchingPlayer) {
                    const weekData = gameLogData[matchingPlayer].weeklyScores.find(w => w.week === week);
                    return weekData ? weekData.points : null;
                }
                return null;
            }
            
            const weekData = playerData.weeklyScores.find(w => w.week === week);
            return weekData ? weekData.points : null;
        }

        async function runSeasonAudit() {
            if (csvData.length === 0 || qbData.length === 0 || Object.keys(gameLogData).length === 0) {
                showAuditStatus('❌ Please upload both CSV files and ensure QB data is loaded', 'error');
                return;
            }

            const minGames = parseInt(document.getElementById('min-games').value) || 10;
            
            document.getElementById('audit-progress').style.display = 'block';
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            const eligibleQBs = qbData.filter(qb => {
                const estimatedGames = Math.floor((qb.total_dropbacks || 0) / 30);
                return estimatedGames >= minGames;
            });

            console.log(`🔍 Found ${eligibleQBs.length} eligible QBs for enhanced statistical audit`);
            
            const auditResults = [];
            
            for (let i = 0; i < eligibleQBs.length; i++) {
                const qb = eligibleQBs[i];
                
                const progress = ((i + 1) / eligibleQBs.length) * 100;
                progressFill.style.width = `${progress}%`;
                progressText.textContent = `Processing ${qb.name} (${i + 1}/${eligibleQBs.length})`;
                
                const qbGames = csvData.filter(game => {
                    const homeTeam = normalizeTeamName(game.home_team);
                    const awayTeam = normalizeTeamName(game.away_team);
                    return homeTeam === qb.team || awayTeam === qb.team;
                });

                if (qbGames.length < minGames) continue;

                const weeklyResults = [];
                let totalProjected = 0;
                let totalActual = 0;
                let boomMatchups = 0;
                let bustMatchups = 0;
                let boomHits = 0;
                let bustHits = 0;
                let projectionErrors = [];
                let totalSquaredError = 0;

                for (const game of qbGames) {
                    try {
                        const homeTeam = normalizeTeamName(game.home_team);
                        const awayTeam = normalizeTeamName(game.away_team);
                        const isHome = homeTeam === qb.team;
                        const opponent = isHome ? awayTeam : homeTeam;
                        
                        const opponentDefense = defenseData.find(def => def.team === opponent);
                        
                        const spread = isHome ? parseFloat(game.dk_spread_home) : parseFloat(game.dk_spread_away);
                        const total = parseFloat(game.dk_total_point);
                        const week = getWeekFromDate(game.commence_time);

                        const gameContext = {
                            spread: isNaN(spread) ? null : spread,
                            total: isNaN(total) ? null : total
                        };

                        const projection = projector.calculateProjection(qb, gameContext, opponentDefense, 95);
                        
                        if (projection && typeof week === 'number') {
                            const projectedFP = projection.totalProjectedFP;
                            const actualFP = getActualFantasyPoints(qb.name, week);
                            const matchupType = projection.matchupAnalysis.matchupType;
                            
                            if (actualFP !== null) {
                                const error = actualFP - projectedFP;
                                projectionErrors.push(error);
                                totalSquaredError += error * error;
                                
                                const wasBoomWeek = actualFP >= 25;
                                const wasBustWeek = actualFP < 15;
                                const withinCI = actualFP >= projection.confidenceInterval.lower && 
                                               actualFP <= projection.confidenceInterval.upper;
                                
                                if (matchupType === 'boom') {
                                    boomMatchups++;
                                    if (wasBoomWeek) boomHits++;
                                } else if (matchupType === 'bust') {
                                    bustMatchups++;
                                    if (wasBustWeek) bustHits++;
                                }

                                weeklyResults.push({
                                    week: week,
                                    date: game.commence_time.split('T')[0],
                                    opponent: opponent,
                                    isHome: isHome,
                                    spread: spread,
                                    total: total,
                                    projected: projectedFP,
                                    actual: actualFP,
                                    diff: error,
                                    accuracy: Math.max(0, 1 - (Math.abs(error) / Math.max(actualFP, 1))),
                                    defenseUsed: !!opponentDefense,
                                    matchupType: matchupType,
                                    wasBoomWeek: wasBoomWeek,
                                    wasBustWeek: wasBustWeek,
                                    withinCI: withinCI,
                                    confidenceInterval: projection.confidenceInterval,
                                    reliabilityScore: projection.statisticalMetrics.reliabilityScore
                                });

                                totalProjected += projectedFP;
                                totalActual += actualFP;
                            }
                        }
                    } catch (error) {
                        console.error('❌ Error processing game:', error);
                    }
                }

                if (weeklyResults.length >= minGames) {
                    // Enhanced statistical metrics
                    const avgAccuracy = weeklyResults.reduce((sum, week) => sum + week.accuracy, 0) / weeklyResults.length;
                    const totalError = Math.abs(totalActual - totalProjected);
                    const totalAccuracy = Math.max(0, 1 - (totalError / Math.max(totalActual, 1)));
                    const defenseDataUsage = weeklyResults.filter(w => w.defenseUsed).length / weeklyResults.length;
                    const boomAccuracy = boomMatchups > 0 ? boomHits / boomMatchups : 0;
                    const bustAccuracy = bustMatchups > 0 ? bustHits / bustMatchups : 0;
                    
                    // Calculate RMSE and MAE
                    const rmse = Math.sqrt(totalSquaredError / weeklyResults.length);
                    const mae = projectionErrors.reduce((sum, err) => sum + Math.abs(err), 0) / weeklyResults.length;
                    
                    // Calculate confidence interval coverage
                    const ciCoverage = weeklyResults.filter(w => w.withinCI).length / weeklyResults.length;
                    
                    // Calculate average reliability score
                    const avgReliability = weeklyResults.reduce((sum, w) => sum + w.reliabilityScore, 0) / weeklyResults.length;

                    auditResults.push({
                        name: qb.name,
                        team: qb.team,
                        gamesPlayed: weeklyResults.length,
                        totalProjected: totalProjected,
                        totalActual: totalActual,
                        totalDiff: totalActual - totalProjected,
                        totalAccuracy: totalAccuracy,
                        avgWeeklyAccuracy: avgAccuracy,
                        defenseDataUsage: defenseDataUsage,
                        boomMatchups: boomMatchups,
                        bustMatchups: bustMatchups,
                        boomHits: boomHits,
                        bustHits: bustHits,
                        boomAccuracy: boomAccuracy,
                        bustAccuracy: bustAccuracy,
                        rmse: rmse,
                        mae: mae,
                        ciCoverage: ciCoverage,
                        avgReliability: avgReliability,
                        weeklyResults: weeklyResults.sort((a, b) => a.week - b.week)
                    });
                }

                await new Promise(resolve => setTimeout(resolve, 10));
            }

            document.getElementById('audit-progress').style.display = 'none';
            auditResults.sort((a, b) => b.totalProjected - a.totalProjected);
            displayEnhancedAuditResults(auditResults);
        }

        function displayEnhancedAuditResults(results) {
            const auditResultsDiv = document.getElementById('audit-results');
            
            if (results.length === 0) {
                auditResultsDiv.innerHTML = '<div class="loading">❌ No qualifying quarterbacks found.</div>';
                return;
            }

            // Calculate aggregate statistics
            const avgAccuracy = results.reduce((sum, qb) => sum + qb.totalAccuracy, 0) / results.length;
            const totalProjected = results.reduce((sum, qb) => sum + qb.totalProjected, 0);
            const totalActual = results.reduce((sum, qb) => sum + qb.totalActual, 0);
            const totalGames = results.reduce((sum, qb) => sum + qb.gamesPlayed, 0);
            const avgDefenseUsage = results.reduce((sum, qb) => sum + qb.defenseDataUsage, 0) / results.length;
            const totalBoomMatchups = results.reduce((sum, qb) => sum + qb.boomMatchups, 0);
            const totalBustMatchups = results.reduce((sum, qb) => sum + qb.bustMatchups, 0);
            const avgBoomAccuracy = results.reduce((sum, qb) => sum + qb.boomAccuracy, 0) / results.length;
            const avgBustAccuracy = results.reduce((sum, qb) => sum + qb.bustAccuracy, 0) / results.length;
            const avgRMSE = results.reduce((sum, qb) => sum + qb.rmse, 0) / results.length;
            const avgMAE = results.reduce((sum, qb) => sum + qb.mae, 0) / results.length;
            const avgCICoverage = results.reduce((sum, qb) => sum + qb.ciCoverage, 0) / results.length;
            const avgReliability = results.reduce((sum, qb) => sum + qb.avgReliability, 0) / results.length;

            let html = `
                <div class="audit-summary">
                    <h2>📊 Enhanced 2024 NFL Season Statistical Audit</h2>
                    <div class="breakdown-grid" style="margin-top: 20px;">
                        <div class="breakdown-item">
                            <div class="breakdown-value">${results.length}</div>
                            <div class="breakdown-label">QBs Analyzed</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${totalGames}</div>
                            <div class="breakdown-label">Total Games</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${(avgAccuracy * 100).toFixed(1)}%</div>
                            <div class="breakdown-label">Avg Accuracy</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${avgRMSE.toFixed(2)}</div>
                            <div class="breakdown-label">Avg RMSE</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${avgMAE.toFixed(2)}</div>
                            <div class="breakdown-label">Avg MAE</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${(avgCICoverage * 100).toFixed(1)}%</div>
                            <div class="breakdown-label">CI Coverage</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${totalBoomMatchups}</div>
                            <div class="breakdown-label">Boom Matchups</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${totalBustMatchups}</div>
                            <div class="breakdown-label">Bust Matchups</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${(avgBoomAccuracy * 100).toFixed(1)}%</div>
                            <div class="breakdown-label">Boom ID Rate</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${(avgBustAccuracy * 100).toFixed(1)}%</div>
                            <div class="breakdown-label">Bust ID Rate</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${avgReliability.toFixed(0)}</div>
                            <div class="breakdown-label">Avg Reliability</div>
                        </div>
                        <div class="breakdown-item">
                            <div class="breakdown-value">${(avgDefenseUsage * 100).toFixed(1)}%</div>
                            <div class="breakdown-label">Defense Data Usage</div>
                        </div>
                    </div>
                </div>
            `;

            results.forEach(qb => {
                const accuracyColor = qb.totalAccuracy > 0.8 ? '#10b981' : qb.totalAccuracy > 0.6 ? '#f59e0b' : '#dc2626';
                const boomColor = qb.boomAccuracy > 0.5 ? '#10b981' : qb.boomAccuracy > 0.3 ? '#f59e0b' : '#dc2626';
                const bustColor = qb.bustAccuracy > 0.5 ? '#10b981' : qb.bustAccuracy > 0.3 ? '#f59e0b' : '#dc2626';
                const reliabilityColor = qb.avgReliability > 75 ? '#10b981' : qb.avgReliability > 50 ? '#f59e0b' : '#dc2626';
                
                html += `
                    <div class="player-audit-card">
                        <div class="player-header">
                            <div>
                                <div class="player-name">${qb.name} (${qb.team})</div>
                                <div style="color: #6b7280; font-size: 0.9rem;">
                                    ${qb.gamesPlayed} games • RMSE: ${qb.rmse.toFixed(1)} • CI Coverage: ${(qb.ciCoverage * 100).toFixed(0)}%
                                </div>
                            </div>
                            <div style="display: flex; gap: 6px; flex-direction: column;">
                                <div class="accuracy-score" style="background-color: ${accuracyColor}; font-size: 0.75rem;">
                                    ${(qb.totalAccuracy * 100).toFixed(1)}% Acc
                                </div>
                                <div class="accuracy-score" style="background-color: ${reliabilityColor}; font-size: 0.75rem;">
                                    ${qb.avgReliability.toFixed(0)} Rel
                                </div>
                                <div class="accuracy-score" style="background-color: ${boomColor}; font-size: 0.75rem;">
                                    ${(qb.boomAccuracy * 100).toFixed(1)}% Boom
                                </div>
                                <div class="accuracy-score" style="background-color: ${bustColor}; font-size: 0.75rem;">
                                    ${(qb.bustAccuracy * 100).toFixed(1)}% Bust
                                </div>
                            </div>
                        </div>
                        
                        <div class="breakdown-grid" style="margin-bottom: 15px;">
                            <div class="breakdown-item">
                                <div class="breakdown-value">${qb.totalProjected.toFixed(1)}</div>
                                <div class="breakdown-label">Total Projected</div>
                            </div>
                            <div class="breakdown-item">
                                <div class="breakdown-value">${qb.totalActual.toFixed(1)}</div>
                                <div class="breakdown-label">Total Actual</div>
                            </div>
                            <div class="breakdown-item">
                                <div class="breakdown-value" style="color: ${qb.totalDiff >= 0 ? '#10b981' : '#dc2626'};">
                                    ${qb.totalDiff >= 0 ? '+' : ''}${qb.totalDiff.toFixed(1)}
                                </div>
                                <div class="breakdown-label">Total Difference</div>
                            </div>
                            <div class="breakdown-item">
                                <div class="breakdown-value">${qb.mae.toFixed(1)}</div>
                                <div class="breakdown-label">Mean Abs Error</div>
                            </div>
                        </div>
                        
                        <h4 style="margin-bottom: 10px;">Weekly Statistical Breakdown:</h4>
                        <div class="weekly-breakdown">
                `;

                qb.weeklyResults.forEach(week => {
                    const diffColor = week.diff >= 0 ? '#10b981' : '#dc2626';
                    const accuracyColor = week.accuracy > 0.8 ? '#10b981' : week.accuracy > 0.6 ? '#f59e0b' : '#dc2626';
                    const homeAway = week.isHome ? 'vs' : '@';
                    const defenseIcon = week.defenseUsed ? '🛡️' : '';
                    const ciIcon = week.withinCI ? '✅' : '❌';
                    
                    // Week item class based on matchup type
                    let weekClass = 'week-item';
                    let matchupIcon = '';
                    if (week.matchupType === 'boom') {
                        weekClass += ' week-boom';
                        matchupIcon = '🚀';
                    } else if (week.matchupType === 'bust') {
                        weekClass += ' week-bust';
                        matchupIcon = '⚠️';
                    } else {
                        matchupIcon = '⚖️';
                    }
                    
                    // Outcome icons
                    let outcomeIcon = '';
                    if (week.wasBoomWeek) outcomeIcon += '⭐';
                    if (week.wasBustWeek) outcomeIcon += '💥';
                    
                    html += `
                        <div class="${weekClass}">
                            <div style="font-weight: 600; margin-bottom: 5px;">
                                Week ${week.week} ${defenseIcon}${matchupIcon}${outcomeIcon}${ciIcon}
                            </div>
                            <div style="font-size: 0.8rem; margin-bottom: 3px;">${homeAway} ${week.opponent}</div>
                            <div style="font-size: 0.7rem; margin-bottom: 3px;">${week.date}</div>
                            <div class="week-projected">P: ${week.projected.toFixed(1)}</div>
                            <div class="week-actual">A: ${week.actual.toFixed(1)}</div>
                            <div class="week-diff" style="color: ${diffColor};">
                                ${week.diff >= 0 ? '+' : ''}${week.diff.toFixed(1)}
                            </div>
                            <div style="color: ${accuracyColor}; font-size: 0.7rem; margin-top: 2px;">
                                ${(week.accuracy * 100).toFixed(0)}% acc
                            </div>
                            <div style="font-size: 0.6rem; color: #6b7280; margin-top: 2px;">
                                R: ${week.reliabilityScore}
                            </div>
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            });

            auditResultsDiv.innerHTML = html;
            showAuditStatus(`🎉 Enhanced statistical audit completed! Analyzed ${results.length} QBs with 95% confidence intervals and comprehensive metrics.`, 'success');
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status-message');
            statusDiv.className = type;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            if (type === 'success' || type === 'loading') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

        function showAuditStatus(message, type) {
            const statusDiv = document.getElementById('audit-status');
            statusDiv.className = type;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            if (type === 'success' || type === 'loading') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }
    </script>
</body>
</html>
