<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clear Edge Sports - Focused Model Audit</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: 'Arial', sans-serif;
        background: #111a29;
        color: white;
        padding: 20px;
        line-height: 1.6;
        position: relative;
        overflow-x: hidden;
        min-height: 100vh;
    }
    
    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            linear-gradient(135deg, #111a29 0%, #1a2332 30%, #0f1419 70%, #111a29 100%);
        z-index: -2;
    }

    body::after {
        content: '';
        position: fixed;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: 
            conic-gradient(from 0deg at 25% 25%, transparent 0deg, rgba(59, 130, 246, 0.08) 45deg, transparent 90deg),
            conic-gradient(from 180deg at 75% 75%, transparent 0deg, rgba(255, 215, 0, 0.08) 45deg, transparent 90deg),
            conic-gradient(from 90deg at 50% 50%, transparent 0deg, rgba(139, 69, 19, 0.05) 30deg, transparent 60deg);
        animation: rotate 25s linear infinite;
        z-index: -1;
    }

    @keyframes rotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        position: relative;
        z-index: 1;
    }
    
    h1 {
        text-align: center;
        color: white;
        margin-bottom: 20px;
        font-size: 2.5rem;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 3px;
        text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
    }

    .subtitle {
        text-align: center;
        color: #FFD700;
        font-size: 16px;
        text-transform: uppercase;
        letter-spacing: 2px;
        font-weight: 700;
        margin-bottom: 30px;
    }
    
    .run-btn {
        display: block;
        margin: 0 auto 30px;
        padding: 15px 40px;
        background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 18px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 0 5px 20px rgba(34, 197, 94, 0.3);
    }
    
    .run-btn:hover {
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 8px 25px rgba(34, 197, 94, 0.5);
    }
    
    .progress-section {
        display: none;
        text-align: center;
        margin: 30px 0;
    }
    
    .progress-bar {
        width: 100%;
        height: 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        overflow: hidden;
        margin: 20px 0;
    }
    
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #FFD700, #22c55e);
        width: 0%;
        transition: width 0.3s ease;
    }
    
    .progress-text {
        color: #FFD700;
        font-weight: 600;
        font-size: 16px;
    }
    
    .results-section {
        display: none;
    }
    
    .results-summary {
        background: rgba(255, 255, 255, 0.03);
        border: 2px solid rgba(255, 215, 0, 0.15);
        border-radius: 20px;
        padding: 30px;
        backdrop-filter: blur(15px);
        position: relative;
        overflow: hidden;
        margin-bottom: 30px;
    }

    .results-summary::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(90deg, transparent, #FFD700, transparent);
        animation: shimmer 3s ease-in-out infinite alternate;
    }

    @keyframes shimmer {
        0% { opacity: 0.3; }
        100% { opacity: 1; }
    }
    
    .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .summary-item {
        text-align: center;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        border: 1px solid rgba(255, 215, 0, 0.2);
    }
    
    .summary-label {
        color: #FFD700;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 8px;
        font-weight: 600;
    }
    
    .summary-value {
        font-size: 20px;
        font-weight: 700;
        color: white;
    }
    
    .audit-table {
        width: 100%;
        background: rgba(255, 255, 255, 0.03);
        border: 2px solid rgba(255, 215, 0, 0.15);
        border-radius: 20px;
        overflow: hidden;
        backdrop-filter: blur(15px);
    }
    
    .audit-table table {
        width: 100%;
        border-collapse: collapse;
    }
    
    .audit-table th {
        background: rgba(255, 215, 0, 0.2);
        color: #FFD700;
        padding: 12px 8px;
        text-align: left;
        font-weight: 700;
        text-transform: uppercase;
        font-size: 11px;
        letter-spacing: 1px;
    }
    
    .audit-table td {
        padding: 10px 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.9);
        font-size: 14px;
    }
    
    .audit-table tr:hover {
        background: rgba(255, 255, 255, 0.05);
    }
    
    .edge-positive {
        color: #22c55e;
        font-weight: 600;
    }
    
    .edge-negative {
        color: #ef4444;
        font-weight: 600;
    }
    
    .edge-neutral {
        color: #FFD700;
        font-weight: 600;
    }
    
    .result-correct {
        color: #22c55e;
        font-weight: 700;
    }
    
    .result-incorrect {
        color: #ef4444;
        font-weight: 700;
    }
    
    .actual-highlight {
        background: rgba(255, 215, 0, 0.2);
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 700;
    }
    
    .error {
        background: rgba(239, 68, 68, 0.1);
        border: 2px solid rgba(239, 68, 68, 0.3);
        color: #ef4444;
        padding: 20px;
        border-radius: 12px;
        margin: 20px 0;
        text-align: center;
        font-weight: 600;
    }
    
    @media (max-width: 768px) {
        .audit-table {
            font-size: 12px;
        }
        
        .audit-table th,
        .audit-table td {
            padding: 6px 4px;
        }
        
        .summary-grid {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <h1>Focused Model Audit</h1>
        <p class="subtitle">23 Selected Players vs Actual Week 10 Results</p>

```
    <button class="run-btn" id="runBtn">Run Model Analysis</button>
    
    <div class="progress-section" id="progressSection">
        <div class="progress-text" id="progressText">Processing projections...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>
    
    <div id="errorDiv" class="error" style="display: none;"></div>
    
    <div class="results-section" id="resultsSection">
        <div class="results-summary">
            <h3 style="color: #FFD700; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 2px;">Model vs Reality Analysis</h3>
            
            <div class="summary-grid" id="summaryGrid">
                <!-- Summary will be populated here -->
            </div>
        </div>
        
        <div class="audit-table" id="auditTable">
            <!-- Results table will be populated here -->
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>

<script>
    // Initialize Supabase
    let supabaseClient = null;
    const SUPABASE_URL = 'https://pyjtwdgapmbdgtpflzan.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB5anR3ZGdhcG1iZGd0cGZsemFuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTExNTEzNTgsImV4cCI6MjA2NjcyNzM1OH0._Bt_XomEPAYRqC6zNgkNDwq66XFlpMoPbNMB6Eb4USo';
    const SEASON = 2024;

    // Selected players data with actual results
    const selectedPlayers = [
        {num: 1, name: "Aaron Jones", game: "Minnesota Vikings @ Jacksonville Jaguars", line: 2.5, actual: 2, team: "Minnesota Vikings", opponent: "Jacksonville Jaguars"},
        {num: 2, name: "Adonai Mitchell", game: "Buffalo Bills @ Indianapolis Colts", line: 2.5, actual: 6, team: "Indianapolis Colts", opponent: "Buffalo Bills"},
        {num: 3, name: "AJ Brown", game: "Philadelphia Eagles @ Dallas Cowboys", line: 4.5, actual: 5, team: "Philadelphia Eagles", opponent: "Dallas Cowboys"},
        {num: 4, name: "Alec Pierce", game: "Buffalo Bills @ Indianapolis Colts", line: 2.5, actual: 4, team: "Indianapolis Colts", opponent: "Buffalo Bills"},
        {num: 5, name: "Alvin Kamara", game: "Atlanta Falcons @ New Orleans Saints", line: 4.5, actual: 5, team: "New Orleans Saints", opponent: "Atlanta Falcons"},
        {num: 6, name: "Amon-Ra St. Brown", game: "Detroit Lions @ Houston Texans", line: 6.5, actual: 6, team: "Detroit Lions", opponent: "Houston Texans"},
        {num: 7, name: "Antonio Gibson", game: "New England Patriots @ Chicago Bears", line: 0.5, actual: 0, team: "New England Patriots", opponent: "Chicago Bears"},
        {num: 9, name: "Austin Ekeler", game: "Pittsburgh Steelers @ Washington Commanders", line: 3.5, actual: 1, team: "Washington Commanders", opponent: "Pittsburgh Steelers"},
        {num: 10, name: "Austin Hooper", game: "New England Patriots @ Chicago Bears", line: 1.5, actual: 3, team: "New England Patriots", opponent: "Chicago Bears"},
        {num: 11, name: "Bijan Robinson", game: "Atlanta Falcons @ New Orleans Saints", line: 3.5, actual: 3, team: "Atlanta Falcons", opponent: "New Orleans Saints"},
        {num: 13, name: "Breece Hall", game: "New York Jets @ Arizona Cardinals", line: 3.5, actual: 4, team: "New York Jets", opponent: "Arizona Cardinals"},
        {num: 14, name: "Brian Thomas Jr", game: "Minnesota Vikings @ Jacksonville Jaguars", line: 4.5, actual: 2, team: "Jacksonville Jaguars", opponent: "Minnesota Vikings"},
        {num: 15, name: "Cade Otton", game: "San Francisco 49ers @ Tampa Bay Buccaneers", line: 5.5, actual: 5, team: "Tampa Bay Buccaneers", opponent: "San Francisco 49ers"},
        {num: 16, name: "Calvin Austin III", game: "Pittsburgh Steelers @ Washington Commanders", line: 1.5, actual: 2, team: "Pittsburgh Steelers", opponent: "Washington Commanders"},
        {num: 17, name: "Calvin Ridley", game: "Tennessee Titans @ Los Angeles Chargers", line: 4.5, actual: 5, team: "Tennessee Titans", opponent: "Los Angeles Chargers"},
        {num: 19, name: "Chase Brown", game: "Cincinnati Bengals @ Baltimore Ravens", line: 3.5, actual: 9, team: "Cincinnati Bengals", opponent: "Baltimore Ravens"},
        {num: 20, name: "Chigoziem Okonkwo", game: "Tennessee Titans @ Los Angeles Chargers", line: 2.5, actual: 1, team: "Tennessee Titans", opponent: "Los Angeles Chargers"},
        {num: 21, name: "Christian McCaffrey", game: "San Francisco 49ers @ Tampa Bay Buccaneers", line: 3.5, actual: 6, team: "San Francisco 49ers", opponent: "Tampa Bay Buccaneers"},
        {num: 25, name: "Courtland Sutton", game: "Denver Broncos @ Kansas City Chiefs", line: 3.5, actual: 6, team: "Denver Broncos", opponent: "Kansas City Chiefs"},
        {num: 28, name: "Dallas Goedert", game: "Philadelphia Eagles @ Dallas Cowboys", line: 2.5, actual: 2, team: "Philadelphia Eagles", opponent: "Dallas Cowboys"},
        {num: 36, name: "De'Von Achane", game: "Miami Dolphins @ Los Angeles Rams", line: 5.5, actual: 5, team: "Miami Dolphins", opponent: "Los Angeles Rams"},
        {num: 38, name: "Deebo Samuel", game: "San Francisco 49ers @ Tampa Bay Buccaneers", line: 4.5, actual: 5, team: "San Francisco 49ers", opponent: "Tampa Bay Buccaneers"},
        {num: 40, name: "DeMario Douglas", game: "New England Patriots @ Chicago Bears", line: 3.5, actual: 4, team: "New England Patriots", opponent: "Chicago Bears"}
    ];

    // Week 10 game flows based on actual results
    const WEEK_10_GAME_FLOWS = {
        "Minnesota Vikings @ Jacksonville Jaguars": {winning_team: "Minnesota Vikings", flow: 2},
        "Buffalo Bills @ Indianapolis Colts": {winning_team: "Buffalo Bills", flow: 4},
        "Philadelphia Eagles @ Dallas Cowboys": {winning_team: "Philadelphia Eagles", flow: 5},
        "Atlanta Falcons @ New Orleans Saints": {winning_team: "Atlanta Falcons", flow: 3},
        "Detroit Lions @ Houston Texans": {winning_team: "Detroit Lions", flow: 3},
        "New England Patriots @ Chicago Bears": {winning_team: "New England Patriots", flow: 2},
        "Pittsburgh Steelers @ Washington Commanders": {winning_team: "Pittsburgh Steelers", flow: 3},
        "New York Jets @ Arizona Cardinals": {winning_team: "Arizona Cardinals", flow: 1},
        "San Francisco 49ers @ Tampa Bay Buccaneers": {winning_team: "San Francisco 49ers", flow: 3},
        "Tennessee Titans @ Los Angeles Chargers": {winning_team: "Los Angeles Chargers", flow: 4},
        "Cincinnati Bengals @ Baltimore Ravens": {winning_team: "Baltimore Ravens", flow: 5},
        "Denver Broncos @ Kansas City Chiefs": {winning_team: "Kansas City Chiefs", flow: 2},
        "Miami Dolphins @ Los Angeles Rams": {winning_team: "Miami Dolphins", flow: 3}
    };

    let auditResults = [];

    window.addEventListener('load', function() {
        if (typeof window.supabase !== 'undefined') {
            supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        } else if (typeof Supabase !== 'undefined') {
            supabaseClient = Supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
        }
        
        document.getElementById('runBtn').addEventListener('click', runAnalysis);
    });

    function getGameFlow(playerTeam, gameKey) {
        const gameData = WEEK_10_GAME_FLOWS[gameKey];
        if (!gameData) return 3; // Default
        
        if (playerTeam === gameData.winning_team) {
            return gameData.flow;
        } else {
            return 6 - gameData.flow; // Inverted for losing team
        }
    }

    async function runAnalysis() {
        const progressSection = document.getElementById('progressSection');
        const resultsSection = document.getElementById('resultsSection');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        
        progressSection.style.display = 'block';
        resultsSection.style.display = 'none';
        auditResults = [];
        
        try {
            for (let i = 0; i < selectedPlayers.length; i++) {
                const player = selectedPlayers[i];
                
                // Update progress
                const progress = ((i + 1) / selectedPlayers.length) * 100;
                progressFill.style.width = `${progress}%`;
                progressText.textContent = `Processing ${i + 1}/${selectedPlayers.length}: ${player.name}`;
                
                // Get game flow
                const gameFlow = getGameFlow(player.team, player.game);
                
                // Get model projection
                const projection = await getModelProjection(player.name, player.opponent, gameFlow);
                
                if (projection && projection.expectedReceptions !== null) {
                    const edge = projection.expectedReceptions - player.line;
                    
                    let modelRecommendation = 'PASS';
                    if (edge >= 0.5) modelRecommendation = 'OVER';
                    else if (edge <= -0.5) modelRecommendation = 'UNDER';
                    
                    // Determine if model was correct
                    let actualResult = 'PUSH';
                    if (player.actual > player.line) actualResult = 'OVER';
                    else if (player.actual < player.line) actualResult = 'UNDER';
                    
                    const modelCorrect = (modelRecommendation === actualResult) || (modelRecommendation === 'PASS' && actualResult === 'PUSH');
                    
                    auditResults.push({
                        num: player.num,
                        player: player.name,
                        team: player.team,
                        opponent: player.opponent,
                        gameFlow: gameFlow,
                        bettingLine: player.line,
                        modelProjection: projection.expectedReceptions,
                        actualReceptions: player.actual,
                        edge: edge,
                        modelRecommendation: modelRecommendation,
                        actualResult: actualResult,
                        modelCorrect: modelCorrect,
                        weightedTPRR: projection.weightedTPRR,
                        targetShare: projection.targetShare,
                        routesPerGame: projection.routesPerGame
                    });
                }
                
                // Small delay
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            displayResults();
            progressSection.style.display = 'none';
            resultsSection.style.display = 'block';
            
        } catch (error) {
            showError(`Analysis failed: ${error.message}`);
            progressSection.style.display = 'none';
        }
    }

    async function getModelProjection(playerName, opponentTeam, gameFlow = 3) {
        try {
            // Get player data
            const { data: playerData, error: playerError } = await supabaseClient
                .from('player_cover_stats')
                .select('team, tprr_player, routes_run, g')
                .eq('player_name', playerName)
                .eq('season', SEASON)
                .eq('coverage_type', 'Overall')
                .limit(1);

            if (playerError || !playerData || playerData.length === 0) {
                console.log(`No player data found for ${playerName}`);
                return null;
            }

            const playerTeam = playerData[0].team;
            const baseTprr = playerData[0].tprr_player || 0.185;
            const targetShare = (baseTprr * 100) || 18.5;
            
            let routesPerGame = 35;
            if (playerData[0].routes_run && playerData[0].g && playerData[0].g > 0) {
                routesPerGame = playerData[0].routes_run / playerData[0].g;
            }

            // Get opponent coverage data
            const { data: coverageData, error: coverageError } = await supabaseClient
                .from('defensive_coverages')
                .select('*')
                .eq('team_name', opponentTeam)
                .eq('season', SEASON)
                .limit(1);

            let coverage = {
                man_pct: 25,
                cover_2_pct: 15,
                cover_3_pct: 30,
                cover_4_pct: 20,
                cover_6_pct: 10
            };

            if (!coverageError && coverageData && coverageData.length > 0) {
                coverage = coverageData[0];
            }

            // Get player coverage stats
            const { data: playerStats, error: statsError } = await supabaseClient
                .from('player_cover_stats')
                .select('coverage_type, tprr_player, separation_score')
                .eq('player_name', playerName)
                .eq('team', playerTeam)
                .eq('season', SEASON)
                .in('coverage_type', ['Man Coverage', 'Cover 2', 'Cover 3', 'Cover 4', 'Cover 6']);

            const coverageTypes = [
                { name: 'Man Coverage', pct: coverage.man_pct || 25 },
                { name: 'Cover 2', pct: coverage.cover_2_pct || 15 },
                { name: 'Cover 3', pct: coverage.cover_3_pct || 30 },
                { name: 'Cover 4', pct: coverage.cover_4_pct || 20 },
                { name: 'Cover 6', pct: coverage.cover_6_pct || 10 }
            ];

            let weightedTPRR = baseTprr * 100;
            let weightedSeparation = 0.2;
            let totalWeight = 0;

            if (!statsError && playerStats && playerStats.length > 0) {
                weightedTPRR = 0;
                weightedSeparation = 0;
                
                coverageTypes.forEach(cov => {
                    const playerStat = playerStats.find(s => s.coverage_type === cov.name);
                    const weight = (cov.pct || 0) / 100;
                    
                    if (playerStat && weight > 0) {
                        weightedTPRR += (playerStat.tprr_player * 100 || baseTprr * 100) * weight;
                        weightedSeparation += (playerStat.separation_score || 0.2) * weight;
                        totalWeight += weight;
                    }
                });
                
                if (totalWeight > 0) {
                    weightedTPRR = weightedTPRR / totalWeight;
                    weightedSeparation = weightedSeparation / totalWeight;
                } else {
                    weightedTPRR = baseTprr * 100;
                    weightedSeparation = 0.2;
                }
            }
            
            // Get defensive matchup stats
            const { data: defStats, error: defError } = await supabaseClient
                .from('defensive_matchups')
                .select('tprr_allowed, catch_rate_allowed')
                .eq('defensive_team_name', opponentTeam)
                .eq('season', SEASON)
                .limit(1);

            const defMatchup = defStats && defStats[0] ? defStats[0] : { 
                tprr_allowed: 0.185, 
                catch_rate_allowed: 63 
            };

            // Calculate projection
            const result = calculateReceptionScore(
                weightedTPRR || 18.5,
                weightedSeparation || 0.2,
                targetShare || 18.5,
                routesPerGame || 35,
                gameFlow || 3,
                50,
                (defMatchup.tprr_allowed || 0.185) * 100,
                defMatchup.catch_rate_allowed || 63
            );

            return {
                playerName,
                playerTeam,
                opponentTeam,
                expectedReceptions: parseFloat(result.expectedReceptions) || 0,
                weightedTPRR: (weightedTPRR || 18.5).toFixed(1),
                targetShare: (targetShare || 18.5).toFixed(1),
                routesPerGame: (routesPerGame || 35).toFixed(1)
            };

        } catch (error) {
            console.error(`Error calculating projection for ${playerName}:`, error);
            return null;
        }
    }

    function calculateReceptionScore(weightedTPRR, weightedSeparation, targetShare, routesPerGame, gameFlow, primaryCoverageFreq, defTPRR, defCatchRate) {
        weightedTPRR = isNaN(weightedTPRR) ? 18.5 : weightedTPRR;
        weightedSeparation = isNaN(weightedSeparation) ? 0.2 : weightedSeparation;
        targetShare = isNaN(targetShare) ? 18.5 : targetShare;
        routesPerGame = isNaN(routesPerGame) ? 35 : routesPerGame;
        gameFlow = isNaN(gameFlow) ? 3 : gameFlow;
        defTPRR = isNaN(defTPRR) ? 18.5 : defTPRR;
        defCatchRate = isNaN(defCatchRate) ? 63 : defCatchRate;
        
        const tprrZScore = (weightedTPRR - 18.5) / 5.0;
        const efficiencyScore = Math.max(0, 50 + (tprrZScore * 15));
        
        const totalOpportunity = (targetShare / 100) * routesPerGame;
        const volumeScore = Math.min(totalOpportunity * 2.5, 100);
        
        const separationZScore = (weightedSeparation - 0.15) / 0.05;
        const separationScore = Math.max(0, 50 + (separationZScore * 12));
        
        const defTPRRZScore = (defTPRR - 18.5) / 3.0;
        const defCatchZScore = (defCatchRate - 63.0) / 5.0;
        const matchupScore = 50 + (defTPRRZScore * 10) + (defCatchZScore * 8);
        
        const gameScriptMultiplier = 0.85 + (gameFlow * 0.075);
        
        const baseScore = (efficiencyScore * 0.30) + 
                            (volumeScore * 0.30) + 
                            (separationScore * 0.15) + 
                            (matchupScore * 0.25);
        
        const finalScore = Math.min(baseScore * gameScriptMultiplier, 100);
        
        const baseReceptions = routesPerGame * (weightedTPRR / 100) * (defCatchRate / 100) * gameScriptMultiplier;
        
        let confidenceFactor = 1.0;
        if (finalScore >= 80) confidenceFactor = 1.15;
        else if (finalScore >= 65) confidenceFactor = 1.05;
        else if (finalScore >= 50) confidenceFactor = 1.0;
        else if (finalScore >= 20) confidenceFactor = 0.95;
```javascript
        else confidenceFactor = 0.85;
        
        const expectedReceptions = Math.max(0, baseReceptions * confidenceFactor).toFixed(1);
        
        return {
            finalScore: finalScore.toFixed(1),
            expectedReceptions
        };
    }

    function displayResults() {
        displaySummary();
        displayTable();
    }

    function displaySummary() {
        const summaryGrid = document.getElementById('summaryGrid');
        
        const totalPlayers = auditResults.length;
        const correctPredictions = auditResults.filter(r => r.modelCorrect).length;
        const accuracy = (correctPredictions / totalPlayers * 100).toFixed(1);
        
        const modelOvers = auditResults.filter(r => r.modelRecommendation === 'OVER').length;
        const modelUnders = auditResults.filter(r => r.modelRecommendation === 'UNDER').length;
        const modelPasses = auditResults.filter(r => r.modelRecommendation === 'PASS').length;
        
        const actualOvers = auditResults.filter(r => r.actualResult === 'OVER').length;
        const actualUnders = auditResults.filter(r => r.actualResult === 'UNDER').length;
        
        const avgModelProjection = auditResults.reduce((sum, r) => sum + r.modelProjection, 0) / totalPlayers;
        const avgActualReceptions = auditResults.reduce((sum, r) => sum + r.actualReceptions, 0) / totalPlayers;
        const avgBettingLine = auditResults.reduce((sum, r) => sum + r.bettingLine, 0) / totalPlayers;
        
        const modelEdgeAccuracy = auditResults.filter(r => 
            (r.edge >= 0.5 && r.actualResult === 'OVER') || 
            (r.edge <= -0.5 && r.actualResult === 'UNDER')
        ).length;
        const edgeAccuracyRate = auditResults.filter(r => Math.abs(r.edge) >= 0.5).length > 0 ? 
            (modelEdgeAccuracy / auditResults.filter(r => Math.abs(r.edge) >= 0.5).length * 100).toFixed(1) : 'N/A';
        
        summaryGrid.innerHTML = `
            <div class="summary-item">
                <div class="summary-label">Total Players</div>
                <div class="summary-value">${totalPlayers}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Model Accuracy</div>
                <div class="summary-value" style="color: ${accuracy >= 60 ? '#22c55e' : accuracy >= 50 ? '#FFD700' : '#ef4444'}">${accuracy}%</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Edge Accuracy</div>
                <div class="summary-value" style="color: ${edgeAccuracyRate >= 60 ? '#22c55e' : '#FFD700'}">${edgeAccuracyRate}%</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Model Overs</div>
                <div class="summary-value">${modelOvers}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Model Unders</div>
                <div class="summary-value">${modelUnders}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Model Passes</div>
                <div class="summary-value">${modelPasses}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Actual Overs</div>
                <div class="summary-value" style="color: #22c55e">${actualOvers}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Actual Unders</div>
                <div class="summary-value" style="color: #ef4444">${actualUnders}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Avg Model Proj</div>
                <div class="summary-value">${avgModelProjection.toFixed(1)}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Avg Actual</div>
                <div class="summary-value">${avgActualReceptions.toFixed(1)}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Avg Betting Line</div>
                <div class="summary-value">${avgBettingLine.toFixed(1)}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Model vs Actual</div>
                <div class="summary-value" style="color: ${avgModelProjection > avgActualReceptions ? '#ef4444' : '#22c55e'}">${(avgModelProjection - avgActualReceptions >= 0 ? '+' : '')}${(avgModelProjection - avgActualReceptions).toFixed(2)}</div>
            </div>
        `;
    }

    function displayTable() {
        const auditTable = document.getElementById('auditTable');
        
        let tableHTML = `
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Player</th>
                        <th>Team</th>
                        <th>vs</th>
                        <th>Line</th>
                        <th>Model</th>
                        <th>Actual</th>
                        <th>Edge</th>
                        <th>Model Rec</th>
                        <th>Actual Result</th>
                        <th>Correct?</th>
                        <th>Game Flow</th>
                        <th>TPRR</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        // Sort by absolute edge (highest first)
        const sortedResults = auditResults.sort((a, b) => Math.abs(b.edge) - Math.abs(a.edge));
        
        sortedResults.forEach(result => {
            const edgeClass = result.edge >= 0.5 ? 'edge-positive' : 
                             result.edge <= -0.5 ? 'edge-negative' : 'edge-neutral';
            
            const correctClass = result.modelCorrect ? 'result-correct' : 'result-incorrect';
            const correctSymbol = result.modelCorrect ? '✅' : '❌';
            
            const displayEdge = `${result.edge >= 0 ? '+' : ''}${result.edge.toFixed(1)}`;
            
            tableHTML += `
                <tr>
                    <td><strong>#${result.num}</strong></td>
                    <td><strong>${result.player}</strong></td>
                    <td>${result.team}</td>
                    <td>${result.opponent}</td>
                    <td>${result.bettingLine}</td>
                    <td><strong>${result.modelProjection.toFixed(1)}</strong></td>
                    <td><span class="actual-highlight">${result.actualReceptions}</span></td>
                    <td class="${edgeClass}">${displayEdge}</td>
                    <td><strong>${result.modelRecommendation}</strong></td>
                    <td><strong>${result.actualResult}</strong></td>
                    <td class="${correctClass}">${correctSymbol}</td>
                    <td>${result.gameFlow}</td>
                    <td>${result.weightedTPRR}%</td>
                </tr>
            `;
        });
        
        tableHTML += `
                </tbody>
            </table>
        `;
        
        auditTable.innerHTML = tableHTML;
    }

    function showError(message) {
        const errorDiv = document.getElementById('errorDiv');
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }
</script>
</body>
</html>
